winsorize_variable <- function(x) {
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
iqr <- IQR(x)
# Winsorization
x <- ifelse(x > q3 + 1.5 * iqr, q3 + 1.5 * iqr, x)
x <- ifelse(x < q1 - 1.5 * iqr, q1 - 1.5 * iqr, x)
x
}
# Loop over all variables
for (variable in variables) {
# Detect outliers
box_plot <- boxplot(subset[[variable]])$out
mtext(paste("Outliers for", variable, ":", paste(box_plot, collapse = ",")))
# Identify rows containing outliers
out_ind <- which(subset[[variable]] %in% c(box_plot))
cat("Indices of outliers for", variable, ":", out_ind, "\n")
cat("Rows with outliers for", variable, ":\n")
print(subset[out_ind,])
# Winsorize the variable and create a new column
winsorized_variable <- paste(variable, "w", sep = "_")
clean_data[[winsorized_variable]] <- winsorize_variable(subset[[variable]])
}
print(clean_data)
# Calculate tmt_diff_w
clean_data <- clean_data %>%
mutate(tmt_diff_w = tmt_b_time_w - tmt_a_time_w)
library(tidyverse)
library(dplyr)
# Import data
alldata <- read.delim("C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/participants.tsv", na.strings = "n/a", header = TRUE)
# Subset of alldata that contains only the important variables
subset <- alldata %>%
select(participant_id,nr, age, sex, group, graduation, years_of_education, neurological_diseases_1, facit_f_FS, hads_a_total_score, hads_d_total_score, psqi_total_score, moca, pvt_reaction_time, nback_miss_1, nback_false_alarm_1 ,nback_miss_2 ,nback_false_alarm_2 ,tmt_a_time,tmt_b_time) %>%
mutate(tmt_diff = tmt_b_time - tmt_a_time)
# Adding the TMT difference
# Convert 'moca' variable to a binary variable based on a cutoff score of 25
# 1 represents scores less than 26 (may) indicating cognitive impairment
# 0 represents scores more than 25 (may) indicating no cognitive impairment
subset <- subset %>%
mutate(moca = ifelse(moca > 25, 0, 1))
# Subset with all relevant cognitive data
cog_subset <- subset %>%
select(participant_id,nr, age, group, pvt_reaction_time, nback_miss_1, nback_false_alarm_1, nback_miss_2, nback_false_alarm_2, tmt_a_time, tmt_b_time)
# Summarize cog_subset
cog_subset %>%
summary()
# Filter to get all "withPCS" rows
# Summary of "withPCS" group
cog_subset %>%
filter(group == "withPCS") %>%
summary(group == "withPCS")
# Filter to get all "withoutPCS" rows
# Summary of "withoutPCS" group
cog_subset %>%
filter(group == "withoutPCS") %>%
summary(group == "withoutPCS")
# Checking for missing values
any(is.na(subset))
# Missing values = TRUE
# Removing rows with missing values
# cog_subset_clean <- cog_subset[complete.cases(cog_subset), ]
subset<- subset %>%
drop_na(pvt_reaction_time, nback_miss_1, nback_miss_2, tmt_a_time, tmt_b_time)
# Summarize cleaned dataframe
subset %>%
summary()
# Variables for which outliers are to be identified and winsorized
variables <- c("pvt_reaction_time","nback_miss_1","nback_miss_2","tmt_a_time","tmt_b_time")
# Initialize clean_data as a copy of subset
clean_data <- subset
# Function to winsorize a variable
winsorize_variable <- function(x) {
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
iqr <- IQR(x)
# Winsorization
x <- ifelse(x > q3 + 1.5 * iqr, q3 + 1.5 * iqr, x)
x <- ifelse(x < q1 - 1.5 * iqr, q1 - 1.5 * iqr, x)
x
}
# Loop over all variables
for (variable in variables) {
# Detect outliers
box_plot <- boxplot(subset[[variable]])$out
mtext(paste("Outliers for", variable, ":", paste(box_plot, collapse = ",")))
# Identify rows containing outliers
out_ind <- which(subset[[variable]] %in% c(box_plot))
cat("Indices of outliers for", variable, ":", out_ind, "\n")
cat("Rows with outliers for", variable, ":\n")
print(subset[out_ind,])
# Winsorize the variable and create a new column
winsorized_variable <- paste(variable, "w", sep = "_")
clean_data[[winsorized_variable]] <- winsorize_variable(subset[[variable]])
}
# Check the clean dataset
print(clean_data)
# Calculate tmt_diff_w
clean_data <- clean_data %>%
mutate(tmt_diff_w = tmt_b_time_w - tmt_a_time_w)
# Print clean_data to verify
print(clean_data)
# Loop over all variables
#for (variable in variables) {
# Detect outliers
#box_plot <- boxplot(subset[[variable]])$out
#mtext(paste("Outliers for", variable, ":", paste(box_plot,
#collapse = ",")))
# Identify rows containing outliers
#out_ind <- which(subset[[variable]] %in% c(box_plot))
#cat("Indices of outliers for", variable, ":", out_ind, "\n")
#cat("Rows with outliers for", variable, ":\n")
#print(subset[out_ind,])
# Remove outliers
#clean_data <- subset[!subset[[variable]] %in% box_plot, ]
#}
# Test correlation
clean_data |>
select(pvt_reaction_time, nback_miss_1, nback_false_alarm_1, nback_miss_2, nback_false_alarm_2, tmt_a_time, tmt_b_time, tmt_diff) |>
cor(use = "pairwise.complete.obs") |>
round(2)
# Scatter plot of tmt_a_time vs. tmt_b_time faceted by age
ggplot(clean_data, aes(x = tmt_a_time, y = tmt_b_time, color = age)) +
geom_point()
# Scatter plot of nback_miss_1 vs. nback_miss_2 faceted by age
ggplot(clean_data, aes(x = nback_miss_1, y = nback_miss_2, color = age)) +
geom_point()
# Function to create age groups
create_age_groups <- function(age) {
if (age >= 18 & age <= 34) {
return("18-34 Years")
} else if (age >= 35 & age <= 49) {
return("35-49 Years")
} else if (age >= 50 & age <= 64) {
return("50-64 Years")
} else if (age >= 65 & age <= 80) {
return("65-80 Years")
}
}
# Function to create age groups for tmt_diff
create_age_groups_tmt_diff <- function(age) {
if (age >= 18 & age <= 24) {
return("18-24 Years")
} else if (age >= 25 & age <= 54) {
return("25-54 Years")
} else if (age >= 55 & age <= 64) {
return("55-64 Years")
} else if (age >= 65 & age <= 80) {
return("65-80 Years")
}
}
# Create age groups
clean_data <- clean_data %>%
mutate(
age_group = sapply(age, create_age_groups),
age_group_tmt_diff = sapply(age, create_age_groups_tmt_diff)
)
# Calculate mean and standard deviation for each age group and variable
age_group_summary <- clean_data %>%
group_by(age_group) %>%
summarize(across(c("pvt_reaction_time_w", "tmt_a_time_w", "tmt_b_time_w"),
list(mean = mean, sd = sd)))
age_group_summary_tmt_diff <- clean_data %>%
group_by(age_group_tmt_diff) %>%
summarize(across(c("tmt_diff_w"),
list(mean = mean, sd = sd)))
View(age_group_summary)
View(age_group_summary_tmt_diff)
View(age_group_summary)
# Function to calculate z-scores
calculate_z_scores <- function(x, mean, sd) {
(x - mean) / sd
}
# Function to calculate z-scores for each individual based on age for all variables
calculate_z_scores_individual <- function(x, age, age_group_summary, age_group_summary_tmt_diff) {
# Find the corresponding age group for each individual
age_group <- sapply(age, create_age_groups)
age_group_tmt_diff <- sapply(age, create_age_groups_tmt_diff)
# Join the age group summary data to the individual data based on age group
individual_data <- data.frame(x, age, age_group) %>%
left_join(age_group_summary, by = "age_group") %>%
left_join(age_group_summary_tmt_diff, by = "age_group_tmt_diff")
# Calculate z-scores for all variables
z_scores <- individual_data %>%
mutate(
z_pvt_reaction_time_w = calculate_z_scores(pvt_reaction_time_w, pvt_reaction_time_w_mean, pvt_reaction_time_w_sd),
z_tmt_a_time_w = calculate_z_scores(tmt_a_time_w, tmt_a_time_w_mean, tmt_a_time_w_sd),
z_tmt_b_time_w = calculate_z_scores(tmt_b_time_w, tmt_b_time_w_mean, tmt_b_time_w_sd),
z_tmt_diff_w = calculate_z_scores(tmt_diff_w, tmt_diff_w_mean, tmt_diff_w_sd)
) %>%
select(starts_with("z_"))
# Combine the Z-scores with the original data
x <- cbind(x, z_scores)
return(x)
}
clean_data <- calculate_z_scores_individual(clean_data, clean_data$age, age_group_summary, age_group_summary_tmt_diff)
# Scale the variables nback_miss_1 and nback_miss_2 and add them as new columns
clean_data <- clean_data %>%
mutate(
s_nback_miss_1_w = as.vector(scale(nback_miss_1_w)),
s_nback_miss_2_w = as.vector(scale(nback_miss_2_w))
)
# clean_data[, c("nback_miss_1","nback_miss_2")] = scale(clean_data[, c("nback_miss_1","nback_miss_2")])
save(clean_data, file = "clean_data.RData")
View(age_group_summary)
# Calculate mean and standard deviation for each age group and variable
age_group_summary <- clean_data %>%
group_by(age_group) %>%
summarize(across(c("pvt_reaction_time_w", "tmt_a_time_w", "tmt_b_time_w","tmt_diff_w", "nback_miss_1_w", "nback_miss_2_w"),
list(mean = mean, sd = sd)))
# Create age groups
clean_data <- clean_data %>%
mutate(
age_group = sapply(age, create_age_groups),
age_group_tmt_diff = sapply(age, create_age_groups_tmt_diff)
)
# Calculate mean and standard deviation for each age group and variable
age_group_summary <- clean_data %>%
group_by(age_group) %>%
summarize(across(c("pvt_reaction_time_w", "tmt_a_time_w", "tmt_b_time_w","tmt_diff_w", "nback_miss_1_w", "nback_miss_2_w"),
list(mean = mean, sd = sd)))
View(age_group_summary)
# K-means
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","pvt_reaction_time","nback_miss_1","nback_miss_2","tmt_a_time","tmt_b_time")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
## k-means
set.seed(123)
km.out <- kmeans(cog_df, centers = 4, nstart = 20)
km.out
## k-means
set.seed(123)
km.out <- kmeans(cog_df, centers = 4, nstart = 20)
km.out
# Decide how many clusters to look at
n_clusters <- 2
# Initialize total within sum of squares error: wss
wss <- numeric(n_clusters)
set.seed(123)
# Look over 1 to n possible clusters
for (i in 1:n_clusters) {
# Fit the model: km.out
km.out <- kmeans(cog_df, centers = i, nstart = 20)
# Save the within cluster sum of squares
wss[i] <- km.out$tot.withinss
}
# Produce a screen plot
wss_df <- tibble(clusters = 1:n_clusters, wss = wss)
scree_plot <- ggplot(wss_df, aes(x = clusters, y = wss, group = 1)) +
geom_point(size = 4) +
geom_line() +
scale_x_continuous(breaks = c(2, 4, 6, 8, 10)) +
xlab('Number of clusters')
scree_plot
scree_plot +
geom_hline(
yintercept = wss,
linetype = 'dashed',
col = c(rep('#000000',3),'#FF0000', rep('#000000', 6))
)
Select number of clusters
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","pvt_reaction_time","nback_miss_1","nback_miss_2","tmt_a_time","tmt_b_time")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
## k-means
set.seed(123)
km.out <- kmeans(cog_df, centers = 4, nstart = 20)
km.out
# Decide how many clusters to look at
n_clusters <- 2
# Initialize total within sum of squares error: wss
wss <- numeric(n_clusters)
set.seed(123)
# Look over 1 to n possible clusters
for (i in 1:n_clusters) {
# Fit the model: km.out
km.out <- kmeans(cog_df, centers = i, nstart = 20)
# Save the within cluster sum of squares
wss[i] <- km.out$tot.withinss
}
# Produce a screen plot
wss_df <- tibble(clusters = 1:n_clusters, wss = wss)
scree_plot <- ggplot(wss_df, aes(x = clusters, y = wss, group = 1)) +
geom_point(size = 4) +
geom_line() +
scale_x_continuous(breaks = c(2, 4, 6, 8, 10)) +
xlab('Number of clusters')
scree_plot
scree_plot +
geom_hline(
yintercept = wss,
linetype = 'dashed',
col = c(rep('#000000',3),'#FF0000', rep('#000000', 6))
)
k <- 4
set.seed(123)
# Build model with k clusters: km.out
km.out <- kmeans(cog_df, centers = k, nstart = 20)
# Append cluster results obtained back in the original dataframe
cog_df_cl <- mutate(cog_df, cluster = km.out$cluster)
# Count how many observations were assigned to each cluster with the count function
count(cog_df_cl, cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster, cog_label)
# Prepare data (count of observations in each cluster for each label category)
cluster_label_counts <- table(cog_label, cog_df_cl$cluster)
# Create bar plot with custom y-axis range and ticks
barplot(cluster_label_counts, beside = TRUE, col = c("blue", "red"),
main = "Cluster Assignments by Label Category", xlab = "Cluster", ylab = "Count",
ylim = c(0, 20),
axes = FALSE)
# Add y-axis with custom ticks and intermediate tick marks
axis(side = 2, at = seq(0, 20, by = 1), labels = FALSE)
axis(side = 2, at = seq(0, 20, by = 5), labels = seq(0, 20, by = 5), tcl = -1)
# Add legend
legend("topleft", legend = c("withoutPCS", "withPCS"), fill = c("blue", "red"))
# Plotting age distribution between clusters with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age)) +
geom_boxplot() +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution between Clusters")
# Plotting age distribution within clusters based on withPCS and withoutPCS labels with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age, fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) + # Adjust position of boxplots
stat_summary(fun = mean, geom = "point", position = position_dodge(width = 0.75), # Adjust position of points
shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)),
position = position_dodge(width = 0.75), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution within Clusters based on withPCS and withoutPCS Labels")
# Vector of variables for which to create boxplots
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time")
# Initialize an empty list to store the plots
plot_list <- list()
# Loop over each variable
for (variable in variables) {
# Create boxplot for the current variable grouped by cluster and fill by group
plot <- ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = !!sym(variable), fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) +
labs(x = "Cluster", y = variable, title = paste("Distribution of", variable, "by Cluster"))
# Append the plot to the list
plot_list[[variable]] <- plot
}
# Arrange plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
# Vector of variables for which to create boxplots
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time")
# Initialize an empty list to store the plots
plot_list <- list()
# Loop over each variable
for (variable in variables) {
# Create boxplot for the current variable grouped by cluster
plot <- ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = !!sym(variable))) +
geom_boxplot(position = position_dodge(width = 0.75)) +
labs(x = "Cluster", y = variable, title = paste("Distribution of", variable, "by Cluster"))
# Append the plot to the list
plot_list[[variable]] <- plot
}
# Arrange plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
# Vector of variables for which to create boxplots
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time")
# Initialize an empty list to store the plots
plot_list <- list()
# Loop over each variable
for (variable in variables) {
# Create boxplot for the current variable grouped by cluster and fill by group
plot <- ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = !!sym(variable), fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) +
labs(x = "Cluster", y = variable, title = paste("Distribution of", variable, "by Cluster"))
# Append the plot to the list
plot_list[[variable]] <- plot
}
# Arrange plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
# Cluster solution for 2 clusters
# Select number of clusters
k <- 2
set.seed(123)
# Build model with k clusters: km.out
km.out <- kmeans(cog_df, centers = k, nstart = 20)
# Append cluster results obtained back in the original dataframe
cog_df_cl <- mutate(cog_df, cluster = km.out$cluster)
# Count how many observations were assigned to each cluster with the count function
count(cog_df_cl, cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster, cog_label)
# Prepare data (count of observations in each cluster for each label category)
cluster_label_counts <- table(cog_label, cog_df_cl$cluster)
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","pvt_reaction_time_z","tmt_a_time_z","tmt_b_time_z")]
load("clean_data.RData")
cog_df <- clean_data[, c("group","pvt_reaction_time_z","tmt_a_time_z","tmt_b_time_z")]
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
set.seed(123)
km.out <- kmeans(cog_df, centers = 4, nstart = 20)
km.out
# Decide how many clusters to look at
n_clusters <- 10
# Initialize total within sum of squares error: wss
wss <- numeric(n_clusters)
set.seed(123)
# Look over 1 to n possible clusters
for (i in 1:n_clusters) {
# Fit the model: km.out
km.out <- kmeans(cog_df, centers = i, nstart = 20)
# Save the within cluster sum of squares
wss[i] <- km.out$tot.withinss
}
# Produce a screen plot
wss_df <- tibble(clusters = 1:n_clusters, wss = wss)
scree_plot <- ggplot(wss_df, aes(x = clusters, y = wss, group = 1)) +
geom_point(size = 4) +
geom_line() +
scale_x_continuous(breaks = c(2, 4, 6, 8, 10)) +
xlab('Number of clusters')
scree_plot
scree_plot +
geom_hline(
yintercept = wss,
linetype = 'dashed',
col = c(rep('#000000',3),'#FF0000', rep('#000000', 6))
)
# Select number of clusters
k <- 2
set.seed(123)
# Build model with k clusters: km.out
km.out <- kmeans(cog_df, centers = k, nstart = 20)
# Append cluster results obtained back in the original dataframe
cog_df_cl <- mutate(cog_df, cluster = km.out$cluster)
# Count how many observations were assigned to each cluster with the count function
count(cog_df_cl, cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster, cog_label)
# Prepare data (count of observations in each cluster for each label category)
cluster_label_counts <- table(cog_label, cog_df_cl$cluster)
# Create bar plot with custom y-axis range and ticks
barplot(cluster_label_counts, beside = TRUE, col = c("blue", "red"),
main = "Cluster Assignments by Label Category", xlab = "Cluster", ylab = "Count",
ylim = c(0, 25),
axes = FALSE)
# Add y-axis with custom ticks and intermediate tick marks
axis(side = 2, at = seq(0, 25, by = 1), labels = FALSE)
axis(side = 2, at = seq(0, 25, by = 5), labels = seq(0, 25, by = 5), tcl = -1)
# Add legend
legend("top", legend = c("withoutPCS", "withPCS"), fill = c("blue", "red"),
bty = "n", xpd = TRUE, inset = c(0, 1.05))
# Plotting age distribution between clusters with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age)) +
geom_boxplot() +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution between Clusters")
# Plotting age distribution within clusters based on withPCS and withoutPCS labels with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age, fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) + # Adjust position of boxplots
stat_summary(fun = mean, geom = "point", position = position_dodge(width = 0.75), # Adjust position of points
shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)),
position = position_dodge(width = 0.75), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution within Clusters based on withPCS and withoutPCS Labels")
# Vector of variables for which to create boxplots
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time")
# Initialize an empty list to store the plots
plot_list <- list()
# Loop over each variable
for (variable in variables) {
# Create boxplot for the current variable grouped by cluster and fill by group
plot <- ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = !!sym(variable), fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) +
labs(x = "Cluster", y = variable, title = paste("Distribution of", variable, "by Cluster"))
# Append the plot to the list
plot_list[[variable]] <- plot
}
# Arrange plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
# Vector of variables for which to create boxplots
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time")
