# Join the age group summary data to the individual data based on age group
individual_data <- data.frame(x, age, age_group) %>%
left_join(age_group_summary, by = "age_group") %>%
left_join(age_group_summary_tmt_diff, by = "age_group_tmt_diff")
# Calculate z-scores for all variables
z_scores <- individual_data %>%
mutate(
z_pvt_reaction_time_w = calculate_z_scores(pvt_reaction_time_w, pvt_reaction_time_w_mean, pvt_reaction_time_w_sd),
z_tmt_a_time_w = calculate_z_scores(tmt_a_time_w, tmt_a_time_w_mean, tmt_a_time_w_sd),
z_tmt_b_time_w = calculate_z_scores(tmt_b_time_w, tmt_b_time_w_mean, tmt_b_time_w_sd),
z_tmt_diff_w = calculate_z_scores(tmt_diff_w, tmt_diff_w_mean, tmt_diff_w_sd)
) %>%
select(starts_with("z_"))
# Combine the Z-scores with the original data
x <- cbind(x, z_scores)
return(x)
}
# Calculate z-scores for each individual based on age for all variables
clean_data <- calculate_z_scores_individual(clean_data, clean_data$age, age_group_summary, age_group_summary_tmt_diff)
# Scale the variables nback_miss_1 and nback_miss_2 and add them as new columns
clean_data <- clean_data %>%
mutate(
s_nback_miss_1_w = as.vector(scale(nback_miss_1_w)),
s_nback_miss_2_w = as.vector(scale(nback_miss_2_w))
)
# clean_data[, c("nback_miss_1","nback_miss_2")] = scale(clean_data[, c("nback_miss_1","nback_miss_2")])
save(clean_data, file = "clean_data.RData")
# Hierarchical clustering
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
library(purrr)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 2)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 2, border = 2:30)
abline(h = 28, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
ward_col_dend <- color_branches(ward_dend_obj, h = 28)
plot(ward_col_dend)
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
# Calculate means and standard deviations for age by cluster
age_stats <- clean_data %>%
group_by(cog_df_cl$cluster) %>%
summarise(
mean = round(mean(age, na.rm = TRUE), 2),
sd = round(sd(age, na.rm = TRUE), 2)
)
# Plotting age distribution between clusters with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age)) +
geom_boxplot() +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution between Clusters")
# Perform t-test for age between clusters
t_test_age <- t.test(age ~ as.factor(cog_df_cl$cluster), data = clean_data)
# Display t-test results
t_test_age
age_stats
# Calculate mean and sd for each group within each cluster
mean_sd_stats <- clean_data %>%
group_by(cog_df_cl$cluster, group) %>%
summarise(
mean = round(mean(age, na.rm = TRUE), 2),
sd = round(sd(age, na.rm = TRUE), 2)
)
# Display mean and sd for each group within each cluster
print(mean_sd_stats)
# Plotting age distribution within clusters based on withPCS and withoutPCS labels with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age, fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) + # Adjust position of boxplots
stat_summary(fun = mean, geom = "point", position = position_dodge(width = 0.75), # Adjust position of points
shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)),
position = position_dodge(width = 0.75), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "age", title = "Age Distribution within Clusters based on withPCS and withoutPCS Labels")
clear
clc
# Hierarchical clustering
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
library(purrr)
library(car)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 4)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 4, border = 2:30)
abline(h = 10, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
ward_col_dend <- color_branches(ward_dend_obj, h = 10)
plot(ward_col_dend)
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
#--------
cluster_info <- clean_data %>%
select(participant_id, cluster)
# Load the participants.tsv file
participants <- read.delim("C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/merged_data.tsv", na.strings = "n/a", header = TRUE)
# Check the structure of participants to identify a common identifier
str(participants)
# Merge the clean_data with participants based on a common identifier
merged_data <- participants %>%
left_join(cluster_info, by = "participant_id")
merged_data <- merged_data %>%
rename(cluster_4 = cluster)
# Check the structure of the merged data to ensure everything is correct
str(merged_data)
# Optionally, save the merged data to a new file
write_tsv(merged_data, "C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/merged_data_all.tsv")
# Calculate means and standard deviations for age by cluster
age_stats <- clean_data %>%
group_by(cog_df_cl$cluster) %>%
summarise(
mean = round(mean(age, na.rm = TRUE), 2),
sd = round(sd(age, na.rm = TRUE), 2)
)
# Plotting age distribution between clusters with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age)) +
# Custom boxplot without median line
stat_boxplot(geom = "errorbar", width = 0.25) +  # Add whiskers
geom_boxplot(aes(group = as.factor(cog_df_cl$cluster)), color = "black", fill = "gray80") +
stat_summary(fun = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), width = 0.75, size = 1, color = "black") +
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)), vjust = -0.5, color = "black") +
labs(x = "Cluster", y = "Age", title = "Age Distribution between Clusters") +
theme_bw()
# Perform ANOVA for age between clusters
anova_age <- aov(age ~ as.factor(cog_df_cl$cluster), data = clean_data)
# Calculate mean and sd for each group within each cluster
mean_sd_stats <- clean_data %>%
group_by(cog_df_cl$cluster, group) %>%
summarise(
mean = round(mean(age, na.rm = TRUE), 2),
sd = round(sd(age, na.rm = TRUE), 2)
)
# Display mean and sd for each group within each cluster
print(mean_sd_stats)
# Plotting age distribution within clusters based on withPCS and withoutPCS labels with mean as text
ggplot(clean_data, aes(x = as.factor(cog_df_cl$cluster), y = age, fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) + # Adjust position of boxplots
stat_summary(fun = mean, geom = "point", position = position_dodge(width = 0.75), # Adjust position of points
shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)),
position = position_dodge(width = 0.75), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "Age", title = "Age Distribution within Clusters based on withPCS and withoutPCS Labels")
# Perform ANOVA for age within "withPCS" group between clusters
anova_withPCS <- aov(age ~ as.factor(cluster), data = subset(clean_data, group == "withPCS"))
# Perform ANOVA for age within "withoutPCS" group between clusters
anova_withoutPCS <- aov(age ~ as.factor(cluster), data = subset(clean_data, group == "withoutPCS"))
# Display ANOVA results for "withPCS" group
summary(anova_withPCS)
# Display ANOVA results for "withoutPCS" group
summary(anova_withoutPCS)
# Cluster 1
cluster_1_data <- subset(clean_data, cluster == 1)
t_test_cluster_1 <- t.test(age ~ group, data = cluster_1_data)
t_test_cluster_1
# Cluster 2
cluster_2_data <- subset(clean_data, cluster == 2)
t_test_cluster_2 <- t.test(age ~ group, data = cluster_2_data)
t_test_cluster_2
# Cluster 3
cluster_3_data <- subset(clean_data, cluster == 3)
t_test_cluster_3 <- t.test(age ~ group, data = cluster_3_data)
t_test_cluster_3
# Cluster 4
cluster_4_data <- subset(clean_data, cluster == 4)
t_test_cluster_4 <- t.test(age ~ group, data = cluster_4_data)
t_test_cluster_4
# Ensure the cluster variable is part of the clean_data dataframe
clean_data$cluster <- cog_df_cl$cluster
# Calculate means of years_of_education by cluster
cluster_means <- tapply(clean_data$years_of_education, clean_data$cluster, FUN = mean)
cluster_means
# Calculate standard deviations of years_of_education by cluster
cluster_sds <- tapply(clean_data$years_of_education, clean_data$cluster, FUN = sd)
cluster_sds
# Combine means and standard deviations into a data frame
cluster_stats <- data.frame(
cluster = names(cluster_means),
mean = round(cluster_means, 2),
sd = round(cluster_sds, 2)
)
# Print the cluster statistics
cluster_stats
# Perform ANOVA for years of education between clusters
anova_education <- aov(years_of_education ~ as.factor(cluster), data = clean_data)
# Display ANOVA results
summary(anova_education)
# Calculate mean and sd for each group within each cluster
mean_sd_stats <- clean_data %>%
group_by(cluster, group) %>%
summarise(
mean = round(mean(years_of_education, na.rm = TRUE), 2),
sd = round(sd(years_of_education, na.rm = TRUE), 2)
)
# Display mean and sd for each group within each cluster
print(mean_sd_stats)
# Perform ANOVA for years of education within the "withPCS" group between clusters
anova_withPCS_education <- aov(years_of_education ~ as.factor(cluster), data = subset(clean_data, group == "withPCS"))
# Display ANOVA results for the "withPCS" group
summary(anova_withPCS_education)
# Perform ANOVA for years of education within the "withoutPCS" group between clusters
anova_withoutPCS_education <- aov(years_of_education ~ as.factor(cluster), data = subset(clean_data, group == "withoutPCS"))
# Display ANOVA results for the "withoutPCS" group
summary(anova_withoutPCS_education)
# Plotting years of education distribution within clusters based on withPCS and withoutPCS labels with mean as text
ggplot(clean_data, aes(x = as.factor(cluster), y = years_of_education, fill = group)) +
geom_boxplot(position = position_dodge(width = 0.75)) + # Adjust position of boxplots
stat_summary(fun = mean, geom = "point", position = position_dodge(width = 0.75), # Adjust position of points
shape = 18, size = 4, color = "red") + # Add mean point
stat_summary(fun = mean, geom = "text", aes(label = round(after_stat(y), 1)),
position = position_dodge(width = 0.75), vjust = -0.5) + # Add mean as text
labs(x = "Cluster", y = "Years of Education", title = "Years of Education Distribution within Clusters based on withPCS and withoutPCS Labels")
# Cluster 1
cluster_1_data <- subset(clean_data, cluster == 1)
t_test_cluster_1 <- t.test(years_of_education ~ group, data = cluster_1_data)
t_test_cluster_1
# Cluster 2
cluster_2_data <- subset(clean_data, cluster == 2)
t_test_cluster_2 <- t.test(years_of_education ~ group, data = cluster_2_data)
t_test_cluster_2
# Cluster 3
cluster_3_data <- subset(clean_data, cluster == 3)
t_test_cluster_3 <- t.test(years_of_education ~ group, data = cluster_3_data)
t_test_cluster_3
# Cluster 4
cluster_4_data <- subset(clean_data, cluster == 4)
t_test_cluster_4 <- t.test(years_of_education ~ group, data = cluster_4_data)
t_test_cluster_4
# Vector of cognitive variables
variables <- c("pvt_reaction_time", "nback_miss_1", "nback_miss_2", "tmt_a_time", "tmt_b_time", "tmt_diff")
# Initialize an empty list to store the plots
plot_list <- list()
# Loop over each variable to create boxplots
for (variable in variables) {
plot <- ggplot(clean_data, aes(x = as.factor(cluster), y = !!sym(variable))) +
geom_boxplot(position = position_dodge(width = 0.75)) +
labs(x = "Cluster", y = variable, title = paste("Distribution of", variable, "by Cluster"))
plot_list[[variable]] <- plot
}
# Arrange plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
# Initialize lists to store results
anova_results <- list()
descriptive_stats_list <- list()
normality_results <- list()
homogeneity_results <- list()
effect_sizes <- list()
# Perform ANOVA, calculate descriptive statistics, check assumptions, and calculate effect sizes
for (variable in variables) {
# Perform ANOVA
anova_result <- aov(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)
anova_results[[variable]] <- summary(anova_result)
# Calculate descriptive statistics
descriptive_stats <- clean_data %>%
group_by(cluster = as.factor(cluster)) %>%
summarise(
mean = round(mean(!!sym(variable), na.rm = TRUE), 2),
sd = round(sd(!!sym(variable), na.rm = TRUE), 2)
) %>%
mutate(
mean = format(mean, nsmall = 2),
sd = format(sd, nsmall = 2)
)
descriptive_stats_list[[variable]] <- descriptive_stats
# Check normality of residuals
# shapiro_test <- shapiro.test(residuals(lm(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)))
#normality_results[[variable]] <- shapiro_test
# Check homogeneity of variances
#levene_test <- car::leveneTest(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)
#homogeneity_results[[variable]] <- levene_test
# Calculate effect size (Eta Squared)
#eta_squared <- summary(anova_result)[[1]][["Sum Sq"]][1] / sum(summary(anova_result)[[1]][["Sum Sq"]])
#effect_sizes[[variable]] <- eta_squared
}
# Perform ANOVA, calculate descriptive statistics, check assumptions, and calculate effect sizes
for (variable in variables) {
# Perform ANOVA
anova_result <- aov(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)
anova_results[[variable]] <- summary(anova_result)
# Calculate descriptive statistics
descriptive_stats <- clean_data %>%
group_by(cluster = as.factor(cluster)) %>%
summarise(
mean = round(mean(!!sym(variable), na.rm = TRUE), 2),
sd = round(sd(!!sym(variable), na.rm = TRUE), 2)
) %>%
mutate(
mean = format(mean, nsmall = 2),
sd = format(sd, nsmall = 2)
)
descriptive_stats_list[[variable]] <- descriptive_stats
# Check normality of residuals
shapiro_test <- shapiro.test(residuals(lm(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)))
normality_results[[variable]] <- shapiro_test
# Check homogeneity of variances
levene_test <- car::leveneTest(clean_data[[variable]] ~ as.factor(cluster), data = clean_data)
homogeneity_results[[variable]] <- levene_test
# Calculate effect size (Eta Squared)
eta_squared <- summary(anova_result)[[1]][["Sum Sq"]][1] / sum(summary(anova_result)[[1]][["Sum Sq"]])
effect_sizes[[variable]] <- eta_squared
}
# Display results
anova_results
descriptive_stats_list
normality_results
homogeneity_results
effect_sizes
# Hierarchical clustering
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
library(purrr)
library(vroom)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 2)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 2, border = 2:30)
abline(h = 28, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
ward_col_dend <- color_branches(ward_dend_obj, h = 28)
plot(ward_col_dend)
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
cluster_info <- clean_data %>%
select(participant_id, cluster)
# Load the participants.tsv file
participants <- read.delim("C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/participants.tsv", na.strings = "n/a", header = TRUE)
# Check the structure of participants to identify a common identifier
str(participants)
# Merge the clean_data with participants based on a common identifier
merged_data <- participants %>%
left_join(cluster_info, by = "participant_id")
merged_data <- merged_data %>%
rename(cluster_2 = cluster)
merged_data <- merged_data %>%
mutate(cluster_2 = recode(cluster_2, '1' = 'badperformer', '2' = 'goodperformer'))
# Check the structure of the merged data to ensure everything is correct
str(merged_data)
# Optionally, save the merged data to a new file
write_tsv(merged_data, "C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/merged_data.tsv")
View(merged_data)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 4)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 4, border = 2:30)
abline(h = 10, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
ward_col_dend <- color_branches(ward_dend_obj, h = 10)
plot(ward_col_dend)
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
#--------
cluster_info <- clean_data %>%
select(participant_id, cluster)
# Load the participants.tsv file
participants <- read.delim("C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/merged_data.tsv", na.strings = "n/a", header = TRUE)
# Check the structure of participants to identify a common identifier
str(participants)
# Merge the clean_data with participants based on a common identifier
merged_data <- participants %>%
left_join(cluster_info, by = "participant_id")
merged_data <- merged_data %>%
rename(cluster_4 = cluster)
# Check the structure of the merged data to ensure everything is correct
str(merged_data)
# Optionally, save the merged data to a new file
write_tsv(merged_data, "C:/Users/jankj/OneDrive/Desktop/masters_thesis/data/merged_data_all.tsv")
