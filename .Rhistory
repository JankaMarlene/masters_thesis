"2" = "#F59541",
"3" = "#B589D6",
"4" = "#4CAF50"
)
# Make sure cluster is a factor with correct levels
clean_data$cluster <- factor(clean_data$cluster, levels = names(color_palette))
# Initialize list for plots
plot_list <- list()
# Loop over variables
for (variable in variables) {
# Get all pairwise combinations of groups
pairwise_comparisons <- combn(levels(clean_data$cluster), 2, simplify = FALSE)
print(paste("Variable:", variable, "—", length(pairwise_comparisons), "pairwise comparisons"))
# Run Wilcoxon tests
p_values_raw <- sapply(pairwise_comparisons, function(groups) {
wilcox.test(
clean_data[[variable]][clean_data$cluster == groups[1]],
clean_data[[variable]][clean_data$cluster == groups[2]],
exact = FALSE
)$p.value
})
# Bonferroni correction
p_adj_bonf <- p.adjust(p_values_raw, method = "bonferroni")
# Use consistent index
sig_idx <- which(!is.na(p_adj_bonf) & p_adj_bonf < 0.05)
significant_comparisons <- pairwise_comparisons[sig_idx]
p_values <- p_adj_bonf[sig_idx]
ylim_buffer <- max(clean_data[[variable]], na.rm = TRUE) * 0.2  # 20% headroom
ymax <- max(clean_data[[variable]], na.rm = TRUE) + ylim_buffer
# Create the plot
plot <- ggplot(clean_data, aes(x = cluster, y = !!sym(variable), color = cluster)) +
geom_boxplot(fill = "white", outlier.shape = NA, width = 0.6, size = 0.9) +
geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
scale_color_manual(values = color_palette) +
labs(x = "", y = variable) +
theme_classic() +
theme(
legend.position = "none",
axis.text.x = element_text(color = NA, angle = 45, hjust = 1),
axis.ticks.x = element_line(),
axis.title.x = element_blank(),
text = element_text(size = 14)
)+
coord_cartesian(ylim = c(NA, ymax * 1.15))
# Add significance bars if any
if (length(significant_comparisons) > 0) {
plot <- plot +
geom_signif(
comparisons = significant_comparisons,
annotations = sapply(p_values, function(p) sprintf("p = %.2g", p)),
color = "black",
textsize = 3.5,
step_increase = 0.15
)
}
# Store plot
plot_list[[variable]] <- plot
}
# Display all plots
grid.arrange(grobs = plot_list, ncol = 2)
# Loop over variables
for (variable in variables) {
# Get all pairwise combinations of groups
pairwise_comparisons <- combn(levels(clean_data$cluster), 2, simplify = FALSE)
print(paste("Variable:", variable, "—", length(pairwise_comparisons), "pairwise comparisons"))
# Run Wilcoxon tests
p_values_raw <- sapply(pairwise_comparisons, function(groups) {
wilcox.test(
clean_data[[variable]][clean_data$cluster == groups[1]],
clean_data[[variable]][clean_data$cluster == groups[2]],
exact = FALSE
)$p.value
})
# Bonferroni correction
p_adj_bonf <- p.adjust(p_values_raw, method = "bonferroni")
# Use consistent index
sig_idx <- which(!is.na(p_adj_bonf) & p_adj_bonf < 0.05)
significant_comparisons <- pairwise_comparisons[sig_idx]
p_values <- p_adj_bonf[sig_idx]
ylim_buffer <- max(clean_data[[variable]], na.rm = TRUE) * 0.2  # 20% headroom
ymax <- max(clean_data[[variable]], na.rm = TRUE) + ylim_buffer
# Create the plot
plot <- ggplot(clean_data, aes(x = cluster, y = !!sym(variable), color = cluster)) +
geom_boxplot(fill = "white", outlier.shape = NA, width = 0.6, size = 0.9) +
geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
scale_color_manual(values = color_palette) +
labs(x = "", y = variable) +
theme_classic() +
theme(
legend.position = "none",
axis.text.x = element_text(color = NA, angle = 45, hjust = 1),
axis.ticks.x = element_line(),
axis.title.x = element_blank(),
text = element_text(size = 14)
)+
coord_cartesian(ylim = c(NA, ymax * 1.15))
# Add significance bars if any
if (length(significant_comparisons) > 0) {
plot <- plot +
geom_signif(
comparisons = significant_comparisons,
annotations = sapply(p_values, function(p) sprintf("p = %.2g", p)),
color = "black",
textsize = 3.5,
step_increase = 0.1
)
}
# Store plot
plot_list[[variable]] <- plot
}
# Display all plots
grid.arrange(grobs = plot_list, ncol = 2)
kruskal_results_cog <- data.frame()
for (variable in variables) {
test <- kruskal.test(as.formula(paste(variable, "cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_cog, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
View(clean_data)
kruskal_results_age <- data.frame()
test <- kruskal.test(as.formula(paste(age, "~ group_combined")), data = clean_data)
kruskal_results_cog <- data.frame()
for (variable in variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_cog, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
View(kruskal_results_cog)
write.csv(significant_results_cog, "kruskal_results_4_cog.csv", row.names = FALSE)
write.csv(kruskal_results_cog, "kruskal_results_4_cog.csv", row.names = FALSE)
# Store all comparison results in a list
all_stats <- list()
# Store all comparison results in a list
all_stats <- list()
for (variable in variables) {
# Pairwise Wilcoxon tests
pairwise_comparisons <- combn(levels(clean_data$cluster), 2, simplify = FALSE)
pairwise_results <- sapply(pairwise_comparisons, function(groups) {
wilcox.test(
clean_data[[variable]][clean_data$cluster == groups[1]],
clean_data[[variable]][clean_data$cluster == groups[2]],
exact = FALSE
)$p.value
})
# Create a summary table
stat_table <- data.frame(
Variable = rep(variable, length(pairwise_results)),
Group1 = sapply(pairwise_comparisons, `[`, 1),
Group2 = sapply(pairwise_comparisons, `[`, 2),
p_value = pairwise_results
)
# Add adjusted p-values (Bonferroni)
stat_table$p_adj_bonferroni <- p.adjust(stat_table$p_value, method = "bonferroni")
# Effect sizes
effsize <- wilcox_effsize(clean_data, formula = as.formula(paste(variable, "~ cluster")))
stat_table <- left_join(stat_table, effsize, by = c("Group1" = "group1", "Group2" = "group2"))
# Store in list
all_stats[[variable]] <- stat_table
}
summary_stats_all <- do.call(rbind, all_stats)
significant_results_cog <- summary_stats_all %>%
filter(!is.na(p_adj_bonferroni) & p_adj_bonferroni < 0.05)
View(significant_results_cog)
write.csv(significant_results_cog, "significant_results_4_cog.csv", row.names = FALSE)
# Vector of variables for which to create boxplots
new_variables <- c("facit_f_FS", "hads_a_total_score", "hads_d_total_score", "psqi_total_score")
# Initialize an empty list to store the plots
plot_list <- list()
# Your 4-group color palette
color_palette <- c(
"1" = "#F5418C",
"2" = "#F59541",
"3" = "#B589D6",
"4" = "#4CAF50"
)
# Make sure cluster is a factor with correct levels
clean_data$cluster <- factor(clean_data$cluster, levels = names(color_palette))
# Initialize list for plots
plot_list <- list()
# Loop over variables
for (variable in new_variables) {
# Get all pairwise combinations of groups
pairwise_comparisons <- combn(levels(clean_data$cluster), 2, simplify = FALSE)
print(paste("Variable:", variable, "—", length(pairwise_comparisons), "pairwise comparisons"))
# Run Wilcoxon tests
p_values_raw <- sapply(pairwise_comparisons, function(groups) {
wilcox.test(
clean_data[[variable]][clean_data$cluster == groups[1]],
clean_data[[variable]][clean_data$cluster == groups[2]],
exact = FALSE
)$p.value
})
# Bonferroni correction
p_adj_bonf <- p.adjust(p_values_raw, method = "bonferroni")
# Use consistent index
sig_idx <- which(!is.na(p_adj_bonf) & p_adj_bonf < 0.05)
significant_comparisons <- pairwise_comparisons[sig_idx]
p_values <- p_adj_bonf[sig_idx]
ylim_buffer <- max(clean_data[[variable]], na.rm = TRUE) * 0.2  # 20% headroom
ymax <- max(clean_data[[variable]], na.rm = TRUE) + ylim_buffer
# Create the plot
plot <- ggplot(clean_data, aes(x = cluster, y = !!sym(variable), color = cluster)) +
geom_boxplot(fill = "white", outlier.shape = NA, width = 0.6, size = 0.9) +
geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
scale_color_manual(values = color_palette) +
labs(x = "", y = variable) +
theme_classic() +
theme(
legend.position = "none",
axis.text.x = element_text(color = NA, angle = 45, hjust = 1),
axis.ticks.x = element_line(),
axis.title.x = element_blank(),
text = element_text(size = 14)
)+
coord_cartesian(ylim = c(NA, ymax * 1.15))
# Add significance bars if any
if (length(significant_comparisons) > 0) {
plot <- plot +
geom_signif(
comparisons = significant_comparisons,
annotations = sapply(p_values, function(p) sprintf("p = %.2g", p)),
color = "black",
textsize = 3.5,
step_increase = 0.1
)
}
# Store plot
plot_list[[variable]] <- plot
}
# Display all plots
grid.arrange(grobs = plot_list, ncol = 2)
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
View(kruskal_results_quest)
# Vector of variables for which to create boxplots
new_variables <- c("facit_f_FS", "hads_a_total_score", "hads_d_total_score", "psqi_total_score")
View(clean_data)
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
# Vector of variables for which to create boxplots
new_variables <- c("facit_f_FS", "hads_a_total_score", "hads_d_total_score", "psqi_total_score")
# Initialize an empty list to store the plots
plot_list <- list()
# Your 4-group color palette
color_palette <- c(
"1" = "#F5418C",
"2" = "#F59541",
"3" = "#B589D6",
"4" = "#4CAF50"
)
# Make sure cluster is a factor with correct levels
clean_data$cluster <- factor(clean_data$cluster, levels = names(color_palette))
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
# Hierarchical clustering
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
library(car)
library(readr)
library(ggdist)
library(ggExtra)# displaying distributions next to plots
library(ggsignif)# displaying stats in plots
library(ggpubr)
library(coin)# need this for z value of wilcox test
library(effectsize)
library(effsize)# for cohens d
library(backports)
library(rstatix)# for wilcox test
library(purrr)
library(FSA)
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
clean_data$group[clean_data$group == "withPCS"] <- "self-reported CD"
clean_data$group[clean_data$group == "withoutPCS"] <- "no self-reported CD"
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_label[cog_label == "withPCS"] <- "self-reported CD"
cog_label[cog_label == "withoutPCS"] <- "no self-reported CD"
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 4)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 4, border = 2:30)
abline(h = 10, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
# Cut into 2 clusters
dend_cut <- cutree(hclust_ward, k = 4)
# Assign cluster labels to dendrogram
ward_col_dend <- color_branches(ward_dend_obj, k = 4)
# Get cluster order to assign colors properly
labels_ordered <- labels(ward_col_dend)
cluster_ordered <- dend_cut[labels_ordered]
# Create a vector of colors corresponding to cluster
cluster_colors <- c(
"1" = "#F59541",   # Green
"2" = "#4CAF50",   # Orange
"3" = "#B589D6",   # Purple
"4" = "#F5418C"    # Pink
)
#custom_colors <- cluster_colors[as.character(cluster_ordered)]
# Apply custom colors to branches
ward_col_dend <- color_branches(ward_dend_obj, k = 4,
col = cluster_colors)
plot(ward_col_dend,
ylab = "Height",
ylim = c(0, 40 + 2))
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
# Vector of variables for which to create boxplots
new_variables <- c("facit_f_FS", "hads_a_total_score", "hads_d_total_score", "psqi_total_score")
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_cog <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
View(kruskal_results_quest)
# Make sure cluster is a factor with correct levels
clean_data$cluster <- factor(clean_data$cluster, levels = names(color_palette))
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_quest <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
# Vector of variables for which to create boxplots
new_variables <- c("facit_f_FS", "hads_a_total_score", "hads_d_total_score", "psqi_total_score")
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = clean_data)
kruskal_results_quest <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
}
write.csv(kruskal_results_quest, "kruskal_results_4_quest.csv", row.names = FALSE)
kruskal_results_quest <- data.frame()
for (variable in new_variables) {
# Subset the data: only keep rows with non-NA for this variable
subset_data <- clean_data[!is.na(clean_data[[variable]]), c(variable, "cluster")]
# Only run test if there are at least 2 unique cluster groups
if (length(unique(subset_data$cluster)) > 1) {
test <- kruskal.test(as.formula(paste(variable, "~ cluster")), data = subset_data)
kruskal_results_quest <- rbind(kruskal_results_quest, data.frame(
Variable = variable,
Chi_squared = round(test$statistic, 3),
df = test$parameter,
p_value = signif(test$p.value, 4)
))
} else {
message(paste("Skipping", variable, "- only one cluster present after NA removal."))
}
}
View(clean_data)
# Hierarchical clustering
library(tidyverse)
library(dplyr)
library(dendextend)
library(ggplot2)
library(gridExtra)
library(purrr)
library(car)
library(readr)
library(ggdist)
library(ggExtra)# displaying distributions next to plots
library(ggsignif)# displaying stats in plots
library(ggpubr)
library(coin)# need this for z value of wilcox test
library(effectsize)
library(effsize)# for cohens d
library(backports)
library(rstatix)# for wilcox test
library(FSA)
library(vroom)
library(cowplot)
theme_set(theme_cowplot())
load("clean_data.RData")
# Extract relevant columns from clean_data
cog_df <- clean_data[, c("group","z_pvt_reaction_time_w","z_tmt_a_time_w","z_tmt_b_time_w")]
clean_data$group[clean_data$group == "withPCS"] <- "self-reported CD"
clean_data$group[clean_data$group == "withoutPCS"] <- "no self-reported CD"
# Check structure and summarize contents of cog_df
str(cog_df)
summary(cog_df)
# Store group labels in a separate variable and exclude label (group column) from the dataset to do clustering
# Later true labels will be used to check how good clustering turned out
cog_label <- cog_df$group
cog_label[cog_label == "withPCS"] <- "self-reported CD"
cog_label[cog_label == "withoutPCS"] <- "no self-reported CD"
cog_df$group <- NULL
str(cog_df)
# Build distance matrix
# Since all values are continuous numerical values I use euclidean distance method
dist_mat <- dist(cog_df, method = 'euclidean')
# Now decide which linkage method to use
# Try different kinds of linkage methods after decide which performed better
# Build dendrogram by plotting hierarchical cluster object with hclust
# Specify linkage method via 'method' argument
hclust_ward <- hclust(dist_mat, method = 'ward')
plot(hclust_ward)
# Create the desired number of clusters
# Since I want two groups 'withPCS' and 'withoutPCS' number of clusters = 2
cut_ward <- cutree(hclust_ward, k = 2)
# To visualize clusters on dendrogram use abline function to draw the cut line
plot(hclust_ward)
rect.hclust(hclust_ward, k = 2, border = 2:30)
abline(h = 28, col = 'red')
# Visualize tree with different colored branches
ward_dend_obj <- as.dendrogram(hclust_ward)
# Cut into 2 clusters
dend_cut <- cutree(hclust_ward, k = 2)
# Assign cluster labels to dendrogram
ward_col_dend <- color_branches(ward_dend_obj, k = 2)
# Get cluster order to assign colors properly
labels_ordered <- labels(ward_col_dend)
cluster_ordered <- dend_cut[labels_ordered]
# Create a vector of colors corresponding to cluster
custom_colors <- ifelse(cluster_ordered == 1, "#F59541", "#02CAF5")
# Apply custom colors to branches
ward_col_dend <- color_branches(ward_dend_obj, k = 2,
col = c("#F59541", "#02CAF5"))
plot(ward_col_dend,
ylab = "Height",
ylim = c(0, 40 + 2))
# Append cluster results obtained back in the original dataframe
# Use mutate
# Count how many observations were assigned to each cluster with the count function
cog_df_cl <- mutate(cog_df, cluster = cut_ward)
count(cog_df_cl,cluster)
# Cross-checking clustering results using table function
table(cog_df_cl$cluster,cog_label)
# Add the cluster information from cog_df_cl to clean_data
clean_data$cluster <- cog_df_cl$cluster
# Check the updated structure of clean_data
str(clean_data)
# Checking sex in cluster
table(cog_df_cl$cluster,clean_data$sex)
View(clean_data)
